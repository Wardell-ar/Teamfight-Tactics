#include <websocketpp/config/asio_no_tls_client.hpp>
#include <websocketpp/client.hpp>
#include <rapidjson/document.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>
#include <iostream>

typedef websocketpp::client<websocketpp::config::asio_client> client;
client c;

void on_message(websocketpp::connection_hdl, client::message_ptr msg) {

    std::cout << msg->get_payload() << std::endl;

    // 解析收到的 JSON 数据
    rapidjson::Document document;
    document.Parse(msg->get_payload().c_str());

    if (!document.IsObject()) {
        std::cerr << "错误：无效的 JSON 数据格式！" << std::endl;
        return;
    }

    // 获取英雄类型
    if (document.HasMember("heroType") && document["heroType"].IsInt()) {
        int heroType = document["heroType"].GetInt();
        std::cout << "英雄类型: " << heroType << std::endl;
    }
}

void on_open(websocketpp::connection_hdl hdl) {
    std::cout << "连接已打开，可以发送消息了！" << std::endl;
    // 创建 RapidJSON 文档
    rapidjson::Document document;
    document.SetObject();

    // 添加英雄类型字段
    rapidjson::Value heroType(1);  // 1 represents the hero type, modify accordingly
    document.AddMember("heroType", heroType, document.GetAllocator());

    // 将 RapidJSON 文档转为字符串
    rapidjson::StringBuffer buffer;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
    document.Accept(writer);
    std::string message = buffer.GetString();

    // 发送 JSON 数据
    c.send(hdl, message, websocketpp::frame::opcode::text);
}

int main(int argc, char* argv[]) {

    std::string uri = "ws://100.81.183.216:9002";

    if (argc == 2) {
        uri = argv[1];
    }

    try {
        // 设置日志记录为相当详细（除了消息负载之外的所有内容）
        c.set_access_channels(websocketpp::log::alevel::all);
        c.clear_access_channels(websocketpp::log::alevel::frame_payload);
        c.set_error_channels(websocketpp::log::elevel::all);

        // 初始化 ASIO
        c.init_asio();

        // 注册消息处理程序
        c.set_message_handler(&on_message);
        c.set_open_handler(&on_open);

        websocketpp::lib::error_code ec;
        client::connection_ptr con = c.get_connection(uri, ec);
        if (ec) {
            std::cout << "无法创建连接，原因是：" << ec.message() << std::endl;
            return 0;
        }

        // 启动 ASIO io_service 运行循环
        c.connect(con);
        c.run();

    }
    catch (websocketpp::exception const& e) {
        std::cout << e.what() << std::endl;
    }

    return 0;
}

