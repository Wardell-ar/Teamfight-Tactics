//此部分添加到头文件上
std::vector<Hero*> allMyHeroes;//我方所有英雄
std::vector<Hero*> allEnemyHeroes;//敌方所有英雄

class Hero :public Sprite {
private:
    int blood;
    int magic;
    int level;//星级
    int camp;//1表示我方阵营，2表示敌方阵营
    int heroType;//英雄种类
    int weapon;//攻击方式
    int power;//攻击力
    bool inBattle;  // 标志是否处于战斗状态

public:
    Hero()
    {
        blood = 100;
        magic = 50;
        level = 1;
    }
    // 创建不同类型的英雄
    static Hero* createHero(int heroType, const Vec2& position, int camp)
    {
        Hero* hero = new Hero();
        if (camp == 1) {
            allMyHeroes.push_back(hero);
        }
        else
            allEnemyHeroes.push_back(hero);

        if (hero)
        {
            hero->autorelease();
            hero->camp = camp;  // 设置阵营
            // 根据不同类型初始化英雄属性
            switch (heroType)
            {
                case 1:
                    // 初始化为第一种类型的英雄
                    hero->initWithFile("hero_one.png");
                    // 可以根据实际需求再调整血量、蓝条、等级等属性
                    hero->blood = 100;
                    hero->magic = 50;
                    hero->level = 1;
                    break;
                    
                case 2:
                    
                    hero->initWithFile("hero_two.png");
                    hero->blood = 100;
                    hero->magic = 50;
                    hero->level = 1;
                    break;
                case 3:

                    hero->initWithFile("hero_three.png");
                    hero->blood = 100;
                    hero->magic = 50;
                    hero->level = 1;
                    break;
                case 4:

                    hero->initWithFile("hero_four.png");
                    hero->blood = 100;
                    hero->magic = 50;
                    hero->level = 1;
                    break;
                case 5:

                    hero->initWithFile("hero_five.png");
                    hero->blood = 100;
                    hero->magic = 50;
                    hero->level = 1;
                    break;
                default:
                    break;
            }
            hero->setPosition(position);
            //保持输出的大小40x40
            hero->setScale(40.0f, 40.0f);
            return hero;
        }

        CC_SAFE_DELETE(hero);
        return nullptr;
    }
    // 移动方法
    void move(Vec2 destination)
    {
        // 使用Cocos引擎提供的动作类来实现移动
        auto moveTo = MoveTo::create(1.0f, destination);
        this->runAction(moveTo);
    }
    // 合成方法
    static void mergeHeroes(std::vector<Hero*>& heroes)
    {
        std::map<int, std::vector<Hero*>> levelMap; // 按等级分类的英雄集合

        // 遍历所有英雄，按等级分类
        for (Hero* hero : heroes)
        {
            int heroLevel = hero->getLevel();
            levelMap[heroLevel].push_back(hero);
        }

        // 遍历分类后的英雄集合，进行合成
        for (auto& pair : levelMap)
        {
            int heroLevel = pair.first;
            std::vector<Hero*>& heroesOfSameLevel = pair.second;

            // 如果有足够的英雄，每三个合成一个更高等级的英雄
            while (heroesOfSameLevel.size() >= 3)
            {
                // 创建一个更高等级的英雄
                Hero* mergedHero = new Hero();
                mergedHero->setLevel(heroLevel + 1);

                // 执行合成操作，这里可以根据实际需求更新血量、蓝条等属性
                // 例如，可以根据合成前的英雄的平均血量、蓝条等来更新新英雄的属性
                // ...

                // 删除被合成的三个英雄
                for (int i = 0; i < 3; ++i)
                {
                    Hero* heroToMerge = heroesOfSameLevel[i];
                    heroes.erase(std::remove(heroes.begin(), heroes.end(), heroToMerge), heroes.end());
                    delete heroToMerge;
                }

                // 将新英雄加入各自阵营
                heroes.push_back(mergedHero);
            }
        }
    }

    // Getter 和 Setter 方法
    int getLevel() const { return level; }
    void setLevel(int newLevel) { level = newLevel; }

    // 进入战斗状态
    void enterBattle()
    {
        inBattle = true;
    }

    // 退出战斗状态
    void exitBattle()
    {
        inBattle = false;
    }

    // 是否处于战斗状态
    bool isInBattle() const
    {
        return inBattle;
    }

    
    // 攻击方法
    void attack()
    {
        // 根据阵营将所有处于战斗状态的英雄分别存储到两个堆里面
        std::vector<Hero*> myHeroes;
        std::vector<Hero*> enemyHeroes;

        // 遍历场上所有英雄
        
        // 你需要根据实际情况修改
        for (auto hero : allMyHeroes)
        {
            if (hero->isInBattle())
            {  
                    myHeroes.push_back(hero);
    
            }
        }
        for (auto hero : allEnemyHeroes)
        {
            if (hero->isInBattle())
            {
                enemyHeroes.push_back(hero);
            }
        }
        // 从两个堆顶各自取出一个英雄进行对决
        while (!myHeroes.empty() && !enemyHeroes.empty())
        {
            Hero* myHero = myHeroes.back();
            Hero* enemyHero = enemyHeroes.back();

            // 进行攻击逻辑，例如减少目标血量等
            myHero->attack(enemyHero);
            if (enemyHero->getBlood() > 0)
                enemyHero->attack(myHero);
            // 如果没有死亡，放回各自堆底
            if (myHero->getBlood() > 0)
                myHeroes.insert(myHeroes.begin(), myHero);
            if (enemyHero->getBlood() > 0)
                enemyHeroes.insert(enemyHeroes.begin(), enemyHero);

            // 弹出堆顶元素
            myHeroes.pop_back();
            enemyHeroes.pop_back();
        }
    }

    // 攻击方法，攻击指定目标
    void attack(Hero* target)
    {
        // 获取敌我英雄位置
        Vec2 myPosition = this->getPosition();
        Vec2 enemyPosition = target->getPosition();

        // 在我方英雄位置生成一支飞箭的图片
        auto arrow = Sprite::create("arrow.png"); // 请替换为实际的箭头图片路径
        arrow->setPosition(myPosition);
        this->getParent()->addChild(arrow);

        // 创建移动动作，一秒后挪到敌方英雄位置
        auto moveTo = MoveTo::create(1.0f, enemyPosition);

        // 创建一个回调动作，在飞箭移动结束后执行扣血逻辑
        auto attackCallback = CallFunc::create([this, target]() {
            // 在这里添加攻击逻辑，例如减少目标血量等
            // ...

            // 示例：减少目标血量
            target->decreaseHealth(power);
            });

        // 创建一个序列动作，先移动，然后执行回调
        auto sequence = Sequence::create(moveTo, attackCallback, nullptr);

        // 运行飞箭动作
        arrow->runAction(sequence);
    }


    // 减少血量方法
    void decreaseHealth(int amount)
    {
        blood -= amount;

        // 如果血量降低到0以下，则死亡
        if (blood <= 0)
        {
            die();
        }
    }

    // 死亡方法
    void die()
    {
        // 在这里可以添加死亡动画等逻辑
        // ...

        // 示例：从场景中移除
        this->removeFromParentAndCleanup(true);

    }

    // 获取阵营
    int getCamp() const
    {
        return camp;
    }

    // 获取血量
    int getBlood() const
    {
        return blood;
    }
};